#!/usr/bin/env python
# Merge haplotype file with two alternate alleles according to recombined regions
# Requires haplotype file and summary file both to be sorted by read name
# For now, only works with two alleles but could be relatively easily expanded

# Example data:
# read    genotype   signal_ref      signal_alt1     signal_alt2     signal_coverage base_ref        base_alt1       base_alt2       base_coverage
# 31a4    fail       41.2219360923   11.7780639077   41.2219360923   53
# 24.9598389445   13.9491907214   24.9598389445   45
from __future__ import print_function
import re
import csv
import argparse

__min_coverage = 5
__override_ratio = 3


def parse_region(region):
    """
    Parse a region specification.
    :param region: String region specification
    :raises argparse.ArgumentTypeError: raises an error if format not recognised
    :returns contig: String contig / chromosome name
    :returns start: integer start position (0-based)
    :returns end: integer end position (1-based)
    >>> parseRegion("chr1:1000-2000")
    ("chr1", 1000, 2000)
    """
    region = ''.join(region.split())  # remove whitespace
    region = re.split(':|-', region)
    start = 0
    end = None
    if len(region) < 1:
        raise argparse.ArgumentTypeError(
            "Region must specify a reference name")
    elif len(region) > 3:
        raise argparse.ArgumentTypeError("Region format not recognized")
    else:
        contig = region[0]
        try:
            start = int(re.sub(",|\.", "", region[1]))
        except IndexError:
            pass
        try:
            end = int(re.sub(",|\.", "", region[2]))
        except IndexError:
            pass
        finally:
            return contig, start, end


def parse_args():
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input', required=True,
                        help='filename of input three-way haplotypes tsv')
    parser.add_argument('-o', '--output', required=True,
                        help='filename of output haplotypes tsv')
    parser.add_argument('-s', '--summary', required=True,
                        help='filename of summary generated by build_supplementary_db')
    parser.add_argument('-a', '--alt-reference', required=True, choices=[
                        'alt1', 'alt2'], help='Name of the allele for which alternate is recombined with the reference')
    parser.add_argument('-r', '--region', type=parse_region, nargs="+", metavar="CHR:START-END",
                        help="Name and range of contigs where reference is replaced by alternate reference")
    parser.add_argument('-b', '--boundary', type=int, default=50000, metavar="INT",
                        help="Width of region boundary where both alleles are included")
    return parser.parse_args()

args = parse_args()

signal_alt_ref = "signal_" + args.alt_reference
base_alt_ref = "base_" + args.alt_reference
signal_alt = "signal_" + "alt1" if args.alt_reference == "alt2" else "alt2"
base_alt = "base_" + "alt1" if args.alt_reference == "alt2" else "alt2"

regions = dict()
# format: { chr : [start, end, alternate_only] }
if args.region:
    for region in args.region:
        try:
            regions[region[0]]
        except KeyError:
            regions[region[0]] = []
        region_start, region_end = region[1], region[2]
        if region_start > 0:
            region_start = region_start + args.boundary // 2
        if region_end is not None:
            region_end = region_end - args.boundary // 2
        regions[region[0]].append([region_start, region_end, True])
        if args.boundary > 1:
            if region[1] > 0:
                regions[region[0]].append(
                    [region[1] - args.boundary // 2, region[1] + args.boundary // 2, False])
            if region[2] is not None:
                regions[region[0]].append(
                    [region[2] - args.boundary // 2, region[2] + args.boundary // 2, False])

with open(args.input, 'r') as haplotype_handle, open(args.summary, 'r') as summary_handle, open(args.output, 'w') as output:
    print("read\tgenotype\tsignal_ref\tsignal_alt\tsignal_coverage\tbase_ref\tbase_alt\tbase_coverage", file=output)
    haplotype_reader = csv.DictReader(haplotype_handle, delimiter="\t")
    summary_reader = csv.DictReader(summary_handle, delimiter="\t", fieldnames=[
                                    'read', 'chr', 'start', 'end', 'qual'])
    summary = next(summary_reader)
    while True:
        try:
            haplotype = next(haplotype_reader)
            while summary['read'] < haplotype['read']:
                summary = next(summary_reader)
                while summary['read'] > haplotype['read']:
                    haplotype = next(haplotype_reader)
            # now they should be the same read
            for key in haplotype.keys():
                if (key.startswith("signal") or key.startswith("base")) and not key.endswith("coverage"):
                    haplotype[key] = float(haplotype[key])
        except StopIteration:
            break

        use_ref = True
        use_alt_ref = False
        if summary['chr'] in regions:
            start = int(summary['start'])
            end = int(summary['end'])
            for region in regions[summary['chr']]:
                if region[0] <= start and region[1] >= end:
                    use_alt_ref = True
                    if region[2]:
                        # alternate only
                        use_ref = False

        if use_ref and use_alt_ref:
            if haplotype['signal_ref'] + haplotype['base_ref'] > haplotype[signal_alt_ref] + haplotype[base_alt_ref]:
                use_alt_ref = False
            elif haplotype['signal_ref'] + haplotype['base_ref'] < haplotype[signal_alt_ref] + haplotype[base_alt_ref]:
                use_ref = False
            else:
                # pick the one with the lower range - more reliable, so
                # probably more accurate
                if abs(haplotype['signal_ref'] - haplotype['base_ref']) < abs(haplotype[signal_alt_ref] - haplotype[base_alt_ref]):
                    use_alt_ref = False
                else:
                    use_ref = False

        if use_ref:
            signal_ref = 'signal_ref'
            base_ref = 'base_ref'
        else:
            signal_ref = signal_alt_ref
            base_ref = base_alt_ref

        # remove excess counts - how?
        signal_coverage = haplotype[signal_ref] + haplotype[signal_alt]
        base_coverage = haplotype[base_ref] + haplotype[base_alt]

        # determine genotype
        signal_call = "fail"
        if signal_coverage > 0:
            signal_ratio = haplotype[signal_ref] / signal_coverage
            if signal_ratio > 0.5:
                signal_call = "ref"
            elif signal_ratio < 0.5:
                signal_call = "alt"

        base_call = "fail"
        if base_coverage > 0:
            base_ratio = haplotype[base_ref] / base_coverage
            if base_ratio > 0.5:
                base_call = "ref"
            elif base_ratio < 0.5:
                base_call = "alt"

        if base_coverage < __min_coverage and signal_coverage < __min_coverage:
            genotype = "fail"
        elif base_call == signal_call:
            genotype = base_call
        elif signal_call == "fail":
            genotype = base_call
        elif base_call == "fail":
            genotype = signal_call
        elif base_coverage > __override_ratio * signal_coverage and base_call != "fail":
            genotype = base_call
        elif signal_coverage > __override_ratio * base_coverage and signal_call != "fail":
            genotype = signal_call
        elif base_ratio - 0.5 > __override_ratio * (signal_ratio - 0.5) and base_ratio > 0.5:
            genotype = base_call
        elif signal_ratio - 0.5 > __override_ratio * (base_ratio - 0.5) and signal_ratio > 0.5:
            genotype = signal_call
        else:
            genotype = "fail"

        print("{read}\t{genotype}\t{signal_ref}\t{signal_alt}\t{signal_coverage}\t{base_ref}\t{base_alt}\t{base_coverage}".format(
            read=haplotype['read'],
            genotype=genotype,
            signal_ref=haplotype[signal_ref],
            base_ref=haplotype[base_ref],
            signal_alt=haplotype[signal_alt],
            base_alt=haplotype[base_alt],
            signal_coverage=haplotype['signal_coverage'],
            base_coverage=haplotype['base_coverage']
        ), file=output)
